# 工作实绩积分模块数据库迁移脚本

## 1. 迁移概述

本迁移脚本用于扩展现有的工作实绩积分模块，添加权限控制功能和界面可见性设置，确保系统能够按照"多干多得、少干少得、不干不得"的原则进行科学评价。

## 2. 迁移脚本

### 2.1 创建权限设置表

```sql
-- 文件名: 026_create_permission_settings.sql
-- 创建权限设置表，用于控制普通用户界面可见性

CREATE TABLE permission_settings (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    setting_key VARCHAR(100) NOT NULL UNIQUE,
    is_enabled BOOLEAN DEFAULT false,
    target_roles JSONB DEFAULT '[]'::jsonb,
    description TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_permission_settings_key ON permission_settings(setting_key);
CREATE INDEX idx_permission_settings_enabled ON permission_settings(is_enabled);
CREATE INDEX idx_permission_settings_created_by ON permission_settings(created_by);

-- 创建更新时间触发器
CREATE TRIGGER update_permission_settings_updated_at 
    BEFORE UPDATE ON permission_settings
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- 启用行级安全策略
ALTER TABLE permission_settings ENABLE ROW LEVEL SECURITY;

-- 创建RLS策略
CREATE POLICY "管理员可管理权限设置" ON permission_settings
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM users 
            WHERE users.id = auth.uid() 
            AND users.role IN ('system_admin', 'assessment_admin')
        )
    );

CREATE POLICY "所有用户可查看权限设置" ON permission_settings
    FOR SELECT USING (true);

-- 授予权限
GRANT ALL PRIVILEGES ON permission_settings TO authenticated;
GRANT SELECT ON permission_settings TO anon;

-- 插入初始权限设置数据
INSERT INTO permission_settings (setting_key, is_enabled, description) VALUES
('daily_evaluation_visible', true, '普通用户日常实绩评价界面可见性'),
('annual_evaluation_visible', true, '普通用户年终集体测评界面可见性'),
('evaluation_result_visible', true, '普通用户评价结果查看权限'),
('personal_score_visible', true, '普通用户个人积分查看权限'),
('statistics_visible', false, '普通用户积分统计分析界面可见性');
```

### 2.2 创建评价批次管理表

```sql
-- 文件名: 027_create_evaluation_batches.sql
-- 创建评价批次表，用于管理评价活动的批次和周期

CREATE TABLE evaluation_batches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    batch_name VARCHAR(200) NOT NULL,
    evaluation_type VARCHAR(20) NOT NULL CHECK (evaluation_type IN ('daily', 'annual')),
    period VARCHAR(20) NOT NULL,
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'completed', 'cancelled')),
    start_date DATE,
    end_date DATE,
    target_users JSONB DEFAULT '[]'::jsonb,
    evaluator_users JSONB DEFAULT '[]'::jsonb,
    description TEXT,
    created_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_evaluation_batches_type ON evaluation_batches(evaluation_type);
CREATE INDEX idx_evaluation_batches_period ON evaluation_batches(period);
CREATE INDEX idx_evaluation_batches_status ON evaluation_batches(status);
CREATE INDEX idx_evaluation_batches_dates ON evaluation_batches(start_date, end_date);
CREATE INDEX idx_evaluation_batches_created_by ON evaluation_batches(created_by);

-- 创建更新时间触发器
CREATE TRIGGER update_evaluation_batches_updated_at 
    BEFORE UPDATE ON evaluation_batches
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- 启用行级安全策略
ALTER TABLE evaluation_batches ENABLE ROW LEVEL SECURITY;

-- 创建RLS策略
CREATE POLICY "管理员可管理评价批次" ON evaluation_batches
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM users 
            WHERE users.id = auth.uid() 
            AND users.role IN ('system_admin', 'assessment_admin', 'leader')
        )
    );

CREATE POLICY "所有用户可查看活跃批次" ON evaluation_batches
    FOR SELECT USING (status = 'active');

CREATE POLICY "评价人员可查看相关批次" ON evaluation_batches
    FOR SELECT USING (
        evaluator_users ? auth.uid()::text OR
        target_users ? auth.uid()::text
    );

-- 授予权限
GRANT ALL PRIVILEGES ON evaluation_batches TO authenticated;
GRANT SELECT ON evaluation_batches TO anon;
```

### 2.3 扩展现有performance_evaluations表

```sql
-- 文件名: 028_extend_performance_evaluations.sql
-- 扩展现有的performance_evaluations表，添加新字段支持批次管理和匿名评价

-- 添加新字段
ALTER TABLE performance_evaluations 
ADD COLUMN IF NOT EXISTS batch_id UUID REFERENCES evaluation_batches(id),
ADD COLUMN IF NOT EXISTS is_anonymous BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS evaluation_round INTEGER DEFAULT 1,
ADD COLUMN IF NOT EXISTS weight_factor DECIMAL(3,2) DEFAULT 1.00 CHECK (weight_factor >= 0 AND weight_factor <= 1),
ADD COLUMN IF NOT EXISTS reviewer_id UUID REFERENCES users(id),
ADD COLUMN IF NOT EXISTS reviewed_at TIMESTAMP WITH TIME ZONE;

-- 创建新索引
CREATE INDEX IF NOT EXISTS idx_performance_evaluations_batch ON performance_evaluations(batch_id);
CREATE INDEX IF NOT EXISTS idx_performance_evaluations_anonymous ON performance_evaluations(is_anonymous);
CREATE INDEX IF NOT EXISTS idx_performance_evaluations_round ON performance_evaluations(evaluation_round);
CREATE INDEX IF NOT EXISTS idx_performance_evaluations_reviewer ON performance_evaluations(reviewer_id);

-- 更新现有RLS策略
DROP POLICY IF EXISTS "评价人员可创建评价记录" ON performance_evaluations;
DROP POLICY IF EXISTS "用户可查看相关评价记录" ON performance_evaluations;

-- 创建新的RLS策略
CREATE POLICY "评价人员可创建评价记录" ON performance_evaluations
    FOR INSERT WITH CHECK (
        auth.uid() = evaluator_id AND
        (
            EXISTS (
                SELECT 1 FROM users 
                WHERE users.id = auth.uid() 
                AND users.role IN ('system_admin', 'assessment_admin', 'leader')
            ) OR
            EXISTS (
                SELECT 1 FROM evaluation_batches eb
                WHERE eb.id = batch_id 
                AND eb.evaluator_users ? auth.uid()::text
                AND eb.status = 'active'
            )
        )
    );

CREATE POLICY "用户可查看相关评价记录" ON performance_evaluations
    FOR SELECT USING (
        user_id = auth.uid() OR 
        evaluator_id = auth.uid() OR
        reviewer_id = auth.uid() OR
        EXISTS (
            SELECT 1 FROM users 
            WHERE users.id = auth.uid() 
            AND users.role IN ('system_admin', 'assessment_admin', 'leader')
        ) OR
        (
            is_anonymous = false AND
            EXISTS (
                SELECT 1 FROM permission_settings ps
                WHERE ps.setting_key = 'evaluation_result_visible'
                AND ps.is_enabled = true
            )
        )
    );

CREATE POLICY "评价人员可更新自己的评价" ON performance_evaluations
    FOR UPDATE USING (
        evaluator_id = auth.uid() AND
        status IN ('draft', 'submitted')
    );

CREATE POLICY "审核人员可审核评价记录" ON performance_evaluations
    FOR UPDATE USING (
        EXISTS (
            SELECT 1 FROM users 
            WHERE users.id = auth.uid() 
            AND users.role IN ('system_admin', 'assessment_admin')
        )
    );
```

### 2.4 扩展final_performance_scores表

```sql
-- 文件名: 029_extend_final_performance_scores.sql
-- 扩展最终积分表，添加更详细的计算信息和历史记录

-- 添加新字段
ALTER TABLE final_performance_scores
ADD COLUMN IF NOT EXISTS calculation_details JSONB DEFAULT '{}'::jsonb,
ADD COLUMN IF NOT EXISTS daily_evaluation_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS annual_evaluation_count INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS last_calculated_at TIMESTAMP WITH TIME ZONE,
ADD COLUMN IF NOT EXISTS is_final BOOLEAN DEFAULT false,
ADD COLUMN IF NOT EXISTS approved_by UUID REFERENCES users(id),
ADD COLUMN IF NOT EXISTS approved_at TIMESTAMP WITH TIME ZONE;

-- 创建新索引
CREATE INDEX IF NOT EXISTS idx_final_performance_scores_period ON final_performance_scores(period);
CREATE INDEX IF NOT EXISTS idx_final_performance_scores_final ON final_performance_scores(is_final);
CREATE INDEX IF NOT EXISTS idx_final_performance_scores_calculated ON final_performance_scores(last_calculated_at);
CREATE INDEX IF NOT EXISTS idx_final_performance_scores_approved ON final_performance_scores(approved_by);

-- 创建计算详情的GIN索引，用于JSON查询
CREATE INDEX IF NOT EXISTS idx_final_performance_scores_details ON final_performance_scores USING GIN (calculation_details);

-- 更新现有约束
ALTER TABLE final_performance_scores
DROP CONSTRAINT IF EXISTS final_performance_scores_user_id_period_key;

ALTER TABLE final_performance_scores
ADD CONSTRAINT final_performance_scores_user_period_unique 
UNIQUE (user_id, period);
```

### 2.5 创建积分计算存储过程

```sql
-- 文件名: 030_create_score_calculation_functions.sql
-- 创建积分计算相关的存储过程和函数

-- 计算最终工作实绩积分的函数
-- 积分计算方式：每位普通职工的工作实绩积分 = 所有参加评分测评人员评分测评分数的总和 ÷ 参评人数（精确到小数点后两位）
CREATE OR REPLACE FUNCTION calculate_final_performance_score(
    p_user_id UUID,
    p_period VARCHAR(20)
) RETURNS DECIMAL(6,2) AS $$
DECLARE
    daily_avg DECIMAL(6,2) := 0;
    annual_avg DECIMAL(6,2) := 0;
    final_score DECIMAL(6,2) := 0;
    daily_count INTEGER := 0;
    annual_count INTEGER := 0;
    calculation_info JSONB;
BEGIN
    -- 计算日常实绩评价平均分（所有参评人员评分的平均值）
    SELECT 
        COALESCE(ROUND(AVG(total_score), 2), 0),
        COUNT(*)
    INTO daily_avg, daily_count
    FROM performance_evaluations
    WHERE user_id = p_user_id 
        AND period = p_period 
        AND evaluation_type = 'daily'
        AND status = 'approved';
    
    -- 计算年终集体测评平均分（所有参评人员评分的平均值）
    SELECT 
        COALESCE(ROUND(AVG(total_score), 2), 0),
        COUNT(*)
    INTO annual_avg, annual_count
    FROM performance_evaluations
    WHERE user_id = p_user_id 
        AND period = p_period 
        AND evaluation_type = 'annual'
        AND status = 'approved';
    
    -- 按公式计算最终积分：日常评价平均分×80% + 年终测评平均分×20%（精确到小数点后两位）
    final_score := ROUND(daily_avg * 0.8 + annual_avg * 0.2, 2);
    
    -- 构建计算详情JSON
    calculation_info := jsonb_build_object(
        'daily_score', daily_avg,
        'annual_score', annual_avg,
        'daily_count', daily_count,
        'annual_count', annual_count,
        'formula', 'daily_score * 0.8 + annual_score * 0.2',
        'calculated_at', NOW()
    );
    
    -- 更新或插入最终积分记录
    INSERT INTO final_performance_scores (
        user_id, 
        period, 
        daily_score, 
        annual_score, 
        final_score,
        daily_evaluation_count,
        annual_evaluation_count,
        calculation_details,
        last_calculated_at
    ) VALUES (
        p_user_id, 
        p_period, 
        daily_avg, 
        annual_avg, 
        final_score,
        daily_count,
        annual_count,
        calculation_info,
        NOW()
    )
    ON CONFLICT (user_id, period) 
    DO UPDATE SET
        daily_score = EXCLUDED.daily_score,
        annual_score = EXCLUDED.annual_score,
        final_score = EXCLUDED.final_score,
        daily_evaluation_count = EXCLUDED.daily_evaluation_count,
        annual_evaluation_count = EXCLUDED.annual_evaluation_count,
        calculation_details = EXCLUDED.calculation_details,
        last_calculated_at = EXCLUDED.last_calculated_at,
        updated_at = NOW();
    
    RETURN final_score;
END;
$$ LANGUAGE plpgsql;

-- 批量计算所有用户指定周期的最终积分
CREATE OR REPLACE FUNCTION calculate_all_final_scores(
    p_period VARCHAR(20)
) RETURNS INTEGER AS $$
DECLARE
    user_record RECORD;
    processed_count INTEGER := 0;
BEGIN
    -- 遍历所有有评价记录的用户
    FOR user_record IN 
        SELECT DISTINCT user_id 
        FROM performance_evaluations 
        WHERE period = p_period AND status = 'approved'
    LOOP
        PERFORM calculate_final_performance_score(user_record.user_id, p_period);
        processed_count := processed_count + 1;
    END LOOP;
    
    RETURN processed_count;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器函数，当评价记录状态变为approved时自动重算积分
CREATE OR REPLACE FUNCTION trigger_recalculate_final_score()
RETURNS TRIGGER AS $$
BEGIN
    -- 当评价记录被批准时，重新计算该用户该周期的最终积分
    IF NEW.status = 'approved' AND (OLD.status IS NULL OR OLD.status != 'approved') THEN
        PERFORM calculate_final_performance_score(NEW.user_id, NEW.period);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 创建触发器
DROP TRIGGER IF EXISTS trigger_performance_evaluation_approved ON performance_evaluations;
CREATE TRIGGER trigger_performance_evaluation_approved
    AFTER UPDATE ON performance_evaluations
    FOR EACH ROW
    EXECUTE FUNCTION trigger_recalculate_final_score();
```

### 2.6 创建权限检查函数

```sql
-- 文件名: 031_create_permission_functions.sql
-- 创建权限检查相关的函数

-- 检查用户是否有特定权限的函数
CREATE OR REPLACE FUNCTION check_user_permission(
    p_user_id UUID,
    p_permission_key VARCHAR(100)
) RETURNS BOOLEAN AS $$
DECLARE
    user_role VARCHAR(50);
    permission_enabled BOOLEAN := false;
BEGIN
    -- 获取用户角色
    SELECT role INTO user_role
    FROM users
    WHERE id = p_user_id;
    
    -- 管理员和考核办管理员拥有所有权限
    IF user_role IN ('system_admin', 'assessment_admin') THEN
        RETURN true;
    END IF;
    
    -- 检查特定权限设置
    SELECT is_enabled INTO permission_enabled
    FROM permission_settings
    WHERE setting_key = p_permission_key;
    
    -- 如果权限设置不存在，默认为false
    RETURN COALESCE(permission_enabled, false);
END;
$$ LANGUAGE plpgsql;

-- 获取用户可访问的评价批次
CREATE OR REPLACE FUNCTION get_user_accessible_batches(
    p_user_id UUID
) RETURNS TABLE(
    batch_id UUID,
    batch_name VARCHAR(200),
    evaluation_type VARCHAR(20),
    period VARCHAR(20),
    status VARCHAR(20)
) AS $$
DECLARE
    user_role VARCHAR(50);
BEGIN
    -- 获取用户角色
    SELECT role INTO user_role
    FROM users
    WHERE id = p_user_id;
    
    -- 管理员可以访问所有批次
    IF user_role IN ('system_admin', 'assessment_admin', 'leader') THEN
        RETURN QUERY
        SELECT eb.id, eb.batch_name, eb.evaluation_type, eb.period, eb.status
        FROM evaluation_batches eb
        ORDER BY eb.created_at DESC;
    ELSE
        -- 普通用户只能访问相关的批次
        RETURN QUERY
        SELECT eb.id, eb.batch_name, eb.evaluation_type, eb.period, eb.status
        FROM evaluation_batches eb
        WHERE eb.status = 'active'
            AND (eb.target_users ? p_user_id::text OR eb.evaluator_users ? p_user_id::text)
        ORDER BY eb.created_at DESC;
    END IF;
END;
$$ LANGUAGE plpgsql;
```

## 3. 迁移执行顺序

1. **026_create_permission_settings.sql** - 创建权限设置表
2. **027_create_evaluation_batches.sql** - 创建评价批次管理表
3. **028_extend_performance_evaluations.sql** - 扩展评价记录表
4. **029_extend_final_performance_scores.sql** - 扩展最终积分表
5. **030_create_score_calculation_functions.sql** - 创建积分计算函数
6. **031_create_permission_functions.sql** - 创建权限检查函数

## 4. 迁移后验证

### 4.1 数据完整性检查

```sql
-- 检查权限设置表
SELECT COUNT(*) as permission_count FROM permission_settings;

-- 检查评价批次表
SELECT COUNT(*) as batch_count FROM evaluation_batches;

-- 检查扩展字段
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'performance_evaluations' 
AND column_name IN ('batch_id', 'is_anonymous', 'evaluation_round');
```

### 4.2 权限策略验证

```sql
-- 检查RLS策略
SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual
FROM pg_policies 
WHERE tablename IN ('permission_settings', 'evaluation_batches', 'performance_evaluations');
```

### 4.3 函数功能测试

```sql
-- 测试权限检查函数
SELECT check_user_permission(
    (SELECT id FROM users WHERE role = 'employee' LIMIT 1),
    'daily_evaluation_visible'
);

-- 测试积分计算函数
SELECT calculate_final_performance_score(
    (SELECT id FROM users LIMIT 1),
    '2024-01'
);
```

## 5. 回滚脚本

如需回滚迁移，请按相反顺序执行以下操作：

```sql
-- 删除函数
DROP FUNCTION IF EXISTS check_user_permission(UUID, VARCHAR);
DROP FUNCTION IF EXISTS get_user_accessible_batches(UUID);
DROP FUNCTION IF EXISTS calculate_final_performance_score(UUID, VARCHAR);
DROP FUNCTION IF EXISTS calculate_all_final_scores(VARCHAR);
DROP FUNCTION IF EXISTS trigger_recalculate_final_score();

-- 删除触发器
DROP TRIGGER IF EXISTS trigger_performance_evaluation_approved ON performance_evaluations;

-- 删除新增字段
ALTER TABLE final_performance_scores 
DROP COLUMN IF EXISTS calculation_details,
DROP COLUMN IF EXISTS daily_evaluation_count,
DROP COLUMN IF EXISTS annual_evaluation_count,
DROP COLUMN IF EXISTS last_calculated_at,
DROP COLUMN IF EXISTS is_final,
DROP COLUMN IF EXISTS approved_by,
DROP COLUMN IF EXISTS approved_at;

ALTER TABLE performance_evaluations 
DROP COLUMN IF EXISTS batch_id,
DROP COLUMN IF EXISTS is_anonymous,
DROP COLUMN IF EXISTS evaluation_round,
DROP COLUMN IF EXISTS weight_factor,
DROP COLUMN IF EXISTS reviewer_id,
DROP COLUMN IF EXISTS reviewed_at;

-- 删除新表
DROP TABLE IF EXISTS evaluation_batches;
DROP TABLE IF EXISTS permission_settings;
```